# **Finding Lane Lines on the Road**

---

**Finding Lane Lines on the Road**

The goals of this project are the following:
* Make a pipeline that finds lane lines on the road


[//]: # (Image References)

[image1]: ./examples/solidYellowCurve2.jpg "InputImage"
[image2]: ./examples/output_gray_solidYellowCurve2.jpg "Grayscale"
[image3]: ./examples/output_hsv_solidYellowCurve2.jpg "HSV"
[image4]: ./examples/output_yellow_white_mask_solidYellowCurve2.jpg "YellowWhiteMask"
[image5]: ./examples/output_masked_image_solidYellowCurve2.jpg "MaskedImage"
[image6]: ./examples/output_edges_solidYellowCurve2.jpg "Edges"
[image7]: ./examples/output_masked_edges_solidYellowCurve2.jpg "MaskedEdges"
[image8]: ./examples/output_hough_lines_solidYellowCurve2.jpg "HoughLines"
[image9]: ./examples/output_solidYellowCurve2.jpg "Output"

---

### Reflection

### 1. Lane Detection Pipeline
 I used the following steps to build the lane detection pipeline.
 Accompanying images show the result of operation of each step on input image
![Input Image][image1]
  
 1. Convert Image To Grayscale
![Grayscale][image2]
  
 2. Convert each image to HSV color space and create a mask to sample only yellow and white colors.
![HSV][image3]
![YelloWhiteMask][image4]
  
 3. Apply the mask from step 2 to grayscale image in step 1 by doing a bitwise and between both the images
![MaskedImage][image5]
 
 4. Apply Gaussian blur to uppress noise and spurious gradients and smooth the image for edge detection
 
 5. Use Canny edge detection to reduce the grayscale image to its edge outlines.
![Edges][image6]
 
 6. Simplify the image further by masking out any regions of the image that arenâ€™t likely to contain lane lines. 
Use a trapezoidal region of interest to mask out unwanted regions.
![MaskedEdges][image7]
 
 7. Apply a Hough Transform to the edges, which will return a collection of line segments wherever lines are detected.
![HoughLines][image8]

 8. Partition these line segments into left and right batches.
 9. For each batch, fit a single straight line to the segments and overlay onto the input image
![Output][image9]


In order to draw a single line on the left and right lanes, I modified the draw_lines() function by sorting the 
hough lines into left and right lanes and then aggregating the left and right line candidates into left and right lanes
The process was as follows:

1. For each line in hough lines collection, calculate the slope and intercept of the line using the following equations.
   
   Slope m = (y2-y1)/(x2-x1)
   
   Intercept b = y1 - m * x1
   
2. Filter out all the vertical and horizontal lines by selecting lines having slope between 0.5 to 1.5
3. Label all the lines having positive slope as right lane candidates and negative slope as left lane candidates
4. Fit a 1-d polynomial to all points of right lane candidates and repeat it for left lane candidates to identify 
left and right lane equations.
5. Use the line equation from step 4 and the region of interest boundaries to form continuous left and right lane.
Each lane cane be drawn using just two points. One point for where the line crosses the bottom of the image 
(where y equals the image vertical size) and one for the point that corresponds to the collected data point that 
has max(x) or min(x) depending upon whether the line slope is positive or negative.


### 2. Issues with the current pipeline

Though pipeline worked great for most of the image frames, It had abberations in challenge video where there was more curvy patch of road, areas of shadows and objects that were considerabely lighter-colored than the rest of the road surface inside the region of interest. For example bridge with almost similar white color to lanes and light gray shadow of trees and other objects on lanes that made color masking masking a bit difficult. 

A potential issue is jittery and flickering lanes. Flicker of lane lines in image frame is mostly due to simplistic binning of hough lines in right and left lane candidates entirely based on a slope range. There are cases where lines returned from hough transformation step don't qualify for either lanes or qualify for just one of them e.g when line slope is close to vertical or horizontal line slope. In some case binning based on just slope also adds false positives(outliers in region of interest where slope is close to one of the left/right lane but intercept is different). In these cases there is no overlay
of lines or wrong overlay in the image frame leading to flickering lane lines.

Another potential shortcoming varying sizes of the left and right lanes in the image frame as I am using max(x) and min(x) of left and right lane candidates repectively to calculate the top end point of lane points. This works well in most of the cases except for the scenarios mentioned in flickering issue.  

### 3. Improvements

Though I have used HSV color space to identify yello and white lane lines, boosting image contrast and color prior to color masking could drastically reduce false positive candidates for canny edge detection.

Once I have changed the hoough lines to slope and interecept parameter space, a k means or dbscan clustering with 4 clusters could find better candidates for left or right lane aggregation as it would account for slope as well intercept while clustering candidates. 

Another potential improvement could be to use a rolling average of left and right lane lines across frames with a specific size and use any additional data obtained from new image frame to adjust slope and intercept. It would help in keeping left and right lane sizes more consistent. It woulds also reduce a flickering by providing more accurate lane lines based on historical data as well make for any left/right lanes detection missing in any image frame.










































































































































































































































































































































































































































































































































































































































































